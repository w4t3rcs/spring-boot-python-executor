package io.w4t3rcs.python.processor;

import com.fasterxml.jackson.databind.ObjectMapper;
import io.w4t3rcs.python.cache.CacheKeyGenerator;
import io.w4t3rcs.python.dto.PythonExecutionResponse;
import io.w4t3rcs.python.exception.PythonCacheException;
import io.w4t3rcs.python.properties.PythonCacheProperties;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;

import java.util.Map;
import java.util.TreeMap;

/**
 * {@link PythonProcessor} implementation that adds caching capabilities
 * for processed Python scripts with arguments.
 * <p>
 * This processor delegates to a wrapped {@link PythonProcessor} instance,
 * caching results based on a cache key generated from the script and sorted arguments.
 * </p>
 * <p>
 * Sorting arguments by key and serializing them as JSON ensures consistent cache keys
 * for logically equivalent argument maps.
 * </p>
 *
 * <p>Usage example:</p>
 * <pre>{@code
 * PythonProcessor baseProcessor = ...;
 * CacheManager cacheManager = ...;
 * PythonCacheProperties cacheProperties = ...;
 * CacheKeyGenerator keyGenerator = ...;
 * ObjectMapper objectMapper = ...;
 *
 * PythonProcessor cachingProcessor = new CachingPythonProcessor(cacheProperties, baseProcessor, cacheManager, keyGenerator, objectMapper);
 *
 * String script = "print('Hello World')";
 * cachingProcessor.process(script);
 * }</pre>
 *
 * @see PythonProcessor
 * @see PythonCacheProperties.NameProperties
 * @see CacheKeyGenerator
 * @author w4t3rcs
 * @since 1.0.0
 */
public class CachingPythonProcessor implements PythonProcessor {
    private final PythonProcessor pythonProcessor;
    private final Cache cache;
    private final CacheKeyGenerator keyGenerator;
    private final ObjectMapper objectMapper;

    /**
     * Constructs a new {@code CachingPythonProcessor}.
     *
     * @param cacheProperties non-null cache properties with processor cache name
     * @param pythonProcessor non-null delegate {@link PythonProcessor} instance
     * @param cacheManager non-null {@link CacheManager} to obtain cache instance
     * @param keyGenerator non-null key generator to generate cache keys
     * @param objectMapper non-null {@link ObjectMapper} for JSON serialization
     */
    public CachingPythonProcessor(PythonCacheProperties cacheProperties, PythonProcessor pythonProcessor, CacheManager cacheManager, CacheKeyGenerator keyGenerator, ObjectMapper objectMapper) {
        this.pythonProcessor = pythonProcessor;
        this.cache = cacheManager.getCache(cacheProperties.name().processor());
        this.keyGenerator = keyGenerator;
        this.objectMapper = objectMapper;
    }

    /**
     * Processes the given Python script with provided arguments and caches the body.
     * <p>
     * The cache key is generated by concatenating the script and JSON serialization
     * of the sorted arguments map. This guarantees stable key generation for
     * logically equivalent argument maps.
     * </p>
     *
     * @param <R> the type of the body
     * @param script non-null Python script to process
     * @param resultClass non-null expected body type
     * @param arguments non-null map of arguments to the script
     * @return body of processing, possibly from cache
     * @throws PythonCacheException if any underlying error occurs during caching or processing
     */
    @Override
    @SuppressWarnings("unchecked")
    public <R> PythonExecutionResponse<R> process(String script, Class<? extends R> resultClass, Map<String, Object> arguments) {
        try {
            Map<String, Object> sortedMap = new TreeMap<>(arguments);
            String argumentsJson = objectMapper.writeValueAsString(sortedMap);
            String body = script + argumentsJson;
            String key = keyGenerator.generateKey(body, resultClass);
            PythonExecutionResponse<R> cachedResult = (PythonExecutionResponse<R>) cache.get(key, PythonExecutionResponse.class);
            if (cachedResult != null) {
                return cachedResult;
            } else {
                PythonExecutionResponse<R> result = pythonProcessor.process(script, resultClass, arguments);
                cache.put(key, result);
                return result;
            }
        } catch (Exception e) {
            throw new PythonCacheException(e);
        }
    }
}